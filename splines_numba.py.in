from __future__ import division

dtype = float

from numba import autojit, jit, double, int64

import numpy as np
from numpy import zeros, array

from math import floor


Ad = array([
   [-1.0/6.0,  3.0/6.0, -3.0/6.0, 1.0/6.0],
   [ 3.0/6.0, -6.0/6.0,  0.0/6.0, 4.0/6.0],
   [-3.0/6.0,  3.0/6.0,  3.0/6.0, 1.0/6.0],
   [ 1.0/6.0,  0.0/6.0,  0.0/6.0, 0.0/6.0]
])

dAd = array([
   [ 0.0, -0.5,  1.0, -0.5],
   [ 0.0,  1.5, -2.0,  0.0],
   [ 0.0, -1.5,  1.0,  0.5],
   [ 0.0,  0.5,  0.0,  0.0]
])

d2Ad = array([
   [ 0.0, 0.0, -1.0,  1.0],
   [ 0.0, 0.0,  3.0, -2.0],
   [ 0.0, 0.0, -3.0,  1.0],
   [ 0.0, 0.0,  1.0,  0.0]
])

from numpy import empty
def eval_UBspline(smin,smax,orders,coefs,svec):
    d,N = svec.shape
#    vals = zeros(N)
    vals = empty(N)
    if d == 1:
        fun = eval_UBspline_1
    elif d == 2:
        fun = eval_UBspline_2
    elif d == 3:
        fun = eval_UBspline_3
    elif d == 4:
        fun = eval_UBspline_4
    fun(smin,smax,orders,coefs,svec,vals,Ad,dAd)
    return vals


{{for d in range(1,max_order+1)}}

#@autojit
@jit("void( double[:], double[:], int64[:], double[{{str.join(',',[':']*d)}}], double[:,:], double[:], double[:,:], double[:,:])") 
def eval_UBspline_{{d}}(smin, smax, orders, coefs, svec, vals, Ad, dAd):
        
    {{for i in range(d)}}
    M{{i}} = orders[{{i}}]
    start{{i}} = smin[{{i}}]
    dinv{{i}} = (orders[{{i}}]-1.0)/(smax[{{i}}]-smin[{{i}}])
    {{endfor}}

    N = svec.shape[1]

    for n in range(N):

        {{for i in range(d)}}
        x{{i}} = svec[{{i}},n]
        {{endfor}}

        {{for i in range(d)}}
        u{{i}} = (x{{i}} - start{{i}})*dinv{{i}}
        i{{i}} = int( floor( u{{i}} ) )
        i{{i}} = max( min(i{{i}},M{{i}}-2), 0 )
        t{{i}} = u{{i}}-i{{i}}
        {{endfor}}


        {{for i in range(d)}}
        tp{{i}}_0 = t{{i}}*t{{i}}*t{{i}};  tp{{i}}_1 = t{{i}}*t{{i}};  tp{{i}}_2 = t{{i}};  tp{{i}}_3 = 1.0;
        {{endfor}}


        {{for i in range(d)}}

        if t{{i}} < 0:
            Phi{{i}}_0 = dAd[0,3]*t{{i}} + Ad[0,3]
            Phi{{i}}_1 = dAd[1,3]*t{{i}} + Ad[1,3]
            Phi{{i}}_2 = dAd[2,3]*t{{i}} + Ad[2,3]
            Phi{{i}}_3 = dAd[3,3]*t{{i}} + Ad[3,3]
        elif t{{i}} > 1:
            Phi{{i}}_0 = (3*Ad[0,0] + 2*Ad[0,1] + Ad[0,2])*(t{{i}}-1) + (Ad[0,0]+Ad[0,1]+Ad[0,2]+Ad[0,3])
            Phi{{i}}_1 = (3*Ad[1,0] + 2*Ad[1,1] + Ad[1,2])*(t{{i}}-1) + (Ad[1,0]+Ad[1,1]+Ad[1,2]+Ad[1,3])
            Phi{{i}}_2 = (3*Ad[2,0] + 2*Ad[2,1] + Ad[2,2])*(t{{i}}-1) + (Ad[2,0]+Ad[2,1]+Ad[2,2]+Ad[2,3])
            Phi{{i}}_3 = (3*Ad[3,0] + 2*Ad[3,1] + Ad[3,2])*(t{{i}}-1) + (Ad[3,0]+Ad[3,1]+Ad[3,2]+Ad[3,3])
        else:
            Phi{{i}}_0 = (Ad[0,0]*tp{{i}}_0 + Ad[0,1]*tp{{i}}_1 + Ad[0,2]*tp{{i}}_2 + Ad[0,3]*tp{{i}}_3)
            Phi{{i}}_1 = (Ad[1,0]*tp{{i}}_0 + Ad[1,1]*tp{{i}}_1 + Ad[1,2]*tp{{i}}_2 + Ad[1,3]*tp{{i}}_3)
            Phi{{i}}_2 = (Ad[2,0]*tp{{i}}_0 + Ad[2,1]*tp{{i}}_1 + Ad[2,2]*tp{{i}}_2 + Ad[2,3]*tp{{i}}_3)
            Phi{{i}}_3 = (Ad[3,0]*tp{{i}}_0 + Ad[3,1]*tp{{i}}_1 + Ad[3,2]*tp{{i}}_2 + Ad[3,3]*tp{{i}}_3)
        {{endfor}}

        vals[n] = {{values[d]}}


{{endfor}}


#{{for d in range(1,max_order+1)}}

#@cython.boundscheck(False)
#@cython.wraparound(False)
#cdef eval_UBspline_{{d}}_g( smin, smax, orders, coefs, double[:,::1] svec):
        
        
    #{{for i in range(d)}}
    #cdef double start{{i}} = smin[{{i}}]
    #cdef double dinv{{i}} = (orders[{{i}}]-1.0)/(smax[{{i}}]-smin[{{i}}])
    #{{endfor}}
                    

    #cdef double val

    #cdef int N = svec.shape[1]

    #cdef int n

    #cdef double[:,::1] Ad = A44d
    #cdef double[:,::1] dAd = dA44d

    #cdef int {{    str.join(', ',['i{}'.format(i) for i in range(d)])   }}
    #cdef double {{    str.join(', ',['x{}'.format(i) for i in range(d)])   }}
    #cdef double {{    str.join(', ',['u{}'.format(i) for i in range(d)])   }}
    #cdef double {{    str.join(', ',['t{}'.format(i) for i in range(d)])   }}
    #cdef double {{    str.join(', ',['extrap{}'.format(i) for i in range(d)])   }}
    
    #cdef double {{    str.join(', ',['Phi{}_{}'.format(i,j) for i in range(d) for j in range(4)])   }}
    #cdef double {{    str.join(', ',['dPhi{}_{}'.format(i,j) for i in range(d) for j in range(4)])   }}
    #cdef double {{    str.join(', ',['tp{}_{}'.format(i,j) for i in range(d) for j in range(4)])   }}

    #cdef double[{{str.join(',',[':']*(d-1)+['::1'])}}] C = coefs

    #cdef double[:] vals = np.zeros(N)
    #cdef double[:,::1] dvals = np.zeros(({{d}},N))

    #cdef double tpx_0, tpx_1, tpx_2, tpx_3
    #cdef double tpy_0, tpy_1, tpy_2, tpy_3

    #with nogil, parallel():

        #for n in prange(N):

            #{{for i in range(d)}}
            #x{{i}} = svec[{{i}},n]
            #{{endfor}}

            
            #{{for i in range(d)}}
            #u{{i}} = (x{{i}} - start{{i}})*dinv{{i}}
            #i{{i}} = <int> u{{i}}
            #t{{i}} = u{{i}}-i{{i}}
            #{{endfor}}

            #{{for i in range(d)}}
            #extrap{{i}} = 0 if (t{{i}} < 0 or t{{i}} >= 1) else 1
            #{{endfor}}

            #{{for i in range(d)}}
            #tp{{i}}_0 = t{{i}}*t{{i}}*t{{i}}*extrap{{i}};  tp{{i}}_1 = t{{i}}*t{{i}};  tp{{i}}_2 = t{{i}};  tp{{i}}_3 = 1.0;
            #{{endfor}}


            #{{for i in range(d)}}
            #Phi{{i}}_0 = (Ad[0,0]*tp{{i}}_0 + Ad[0,1]*tp{{i}}_1 + Ad[0,2]*tp{{i}}_2 + Ad[0,3]*tp{{i}}_3)
            #Phi{{i}}_1 = (Ad[1,0]*tp{{i}}_0 + Ad[1,1]*tp{{i}}_1 + Ad[1,2]*tp{{i}}_2 + Ad[1,3]*tp{{i}}_3)
            #Phi{{i}}_2 = (Ad[2,0]*tp{{i}}_0 + Ad[2,1]*tp{{i}}_1 + Ad[2,2]*tp{{i}}_2 + Ad[2,3]*tp{{i}}_3)
            #Phi{{i}}_3 = (Ad[3,0]*tp{{i}}_0 + Ad[3,1]*tp{{i}}_1 + Ad[3,2]*tp{{i}}_2 + Ad[3,3]*tp{{i}}_3)
            #{{endfor}}

            #{{for i in range(d)}}
            #dPhi{{i}}_0 = (dAd[0,0]*tp{{i}}_0 + dAd[0,1]*tp{{i}}_1 + dAd[0,2]*tp{{i}}_2 + dAd[0,3]*tp{{i}}_3)*dinv{{i}}
            #dPhi{{i}}_1 = (dAd[1,0]*tp{{i}}_0 + dAd[1,1]*tp{{i}}_1 + dAd[1,2]*tp{{i}}_2 + dAd[1,3]*tp{{i}}_3)*dinv{{i}}
            #dPhi{{i}}_2 = (dAd[2,0]*tp{{i}}_0 + dAd[2,1]*tp{{i}}_1 + dAd[2,2]*tp{{i}}_2 + dAd[2,3]*tp{{i}}_3)*dinv{{i}}
            #dPhi{{i}}_3 = (dAd[3,0]*tp{{i}}_0 + dAd[3,1]*tp{{i}}_1 + dAd[3,2]*tp{{i}}_2 + dAd[3,3]*tp{{i}}_3)*dinv{{i}}
            #{{endfor}}


            #vals[n] = {{values[d]}}

            #{{for i in range(d)}}
            #dvals[{{i}},n] = {{dvalues[d][i]}} 
            #{{endfor}}

    #return [vals,dvals]

#{{endfor}}
